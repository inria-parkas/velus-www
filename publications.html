<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta content="ie=edge" http-equiv="x-ua-compatible"/><link href="velus.css" rel="stylesheet"/><title>Vélus Publications</title><meta description="Publications by the Vélus team."/><link href="icons/apple-icon-512x512.png" rel="apple-touch-icon" sizes="512x512"/><link href="icons/apple-icon-196x196.png" rel="apple-touch-icon" sizes="196x196"/><link href="icons/apple-icon-180x180.png" rel="apple-touch-icon" sizes="180x180"/><link href="icons/apple-icon-172x172.png" rel="apple-touch-icon" sizes="172x172"/><link href="icons/apple-icon-167x167.png" rel="apple-touch-icon" sizes="167x167"/><link href="icons/apple-icon-152x152.png" rel="apple-touch-icon" sizes="152x152"/><link href="icons/apple-icon-144x144.png" rel="apple-touch-icon" sizes="144x144"/><link href="icons/apple-icon-120x120.png" rel="apple-touch-icon" sizes="120x120"/><link href="icons/apple-icon-114x114.png" rel="apple-touch-icon" sizes="114x114"/><link href="icons/apple-icon-100x100.png" rel="apple-touch-icon" sizes="100x100"/><link href="icons/apple-icon-88x88.png" rel="apple-touch-icon" sizes="88x88"/><link href="icons/apple-icon-87x87.png" rel="apple-touch-icon" sizes="87x87"/><link href="icons/apple-icon-80x80.png" rel="apple-touch-icon" sizes="80x80"/><link href="icons/apple-icon-76x76.png" rel="apple-touch-icon" sizes="76x76"/><link href="icons/apple-icon-72x72.png" rel="apple-touch-icon" sizes="72x72"/><link href="icons/apple-icon-60x60.png" rel="apple-touch-icon" sizes="60x60"/><link href="icons/apple-icon-58x58.png" rel="apple-touch-icon" sizes="58x58"/><link href="icons/apple-icon-57x57.png" rel="apple-touch-icon" sizes="57x57"/><link href="icons/apple-icon-55x55.png" rel="apple-touch-icon" sizes="55x55"/><link href="icons/apple-icon-50x50.png" rel="apple-touch-icon" sizes="50x50"/><link href="icons/apple-icon-48x48.png" rel="apple-touch-icon" sizes="48x48"/><link href="icons/apple-icon-40x40.png" rel="apple-touch-icon" sizes="40x40"/><link href="icons/apple-icon-29x29.png" rel="apple-touch-icon" sizes="29x29"/><link href="icons/apple-icon-20x20.png" rel="apple-touch-icon" sizes="20x20"/><link href="icons/icon-256x256.png" type="image/png" rel="icon" sizes="256x256"/><link href="icons/icon-128x128.png" type="image/png" rel="icon" sizes="128x128"/><link href="icons/icon-96x96.png" type="image/png" rel="icon" sizes="96x96"/><link href="icons/icon-64x64.png" type="image/png" rel="icon" sizes="64x64"/><link href="icons/icon-48x48.png" type="image/png" rel="icon" sizes="48x48"/><link href="icons/icon-32x32.png" type="image/png" rel="icon" sizes="32x32"/><link href="icons/icon-24x24.png" type="image/png" rel="icon" sizes="24x24"/><link href="icons/icon-16x16.png" type="image/png" rel="icon" sizes="16x16"/><link href="/icons/manifest.json" rel="manifest"/><meta name="msapplication-TileColor" content="#ffffff"/><meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png"/><meta name="theme-color" content="#ffffff"/></head><body><div class="velus-all"><div class="velus-content" data-spy="scroll" data-target="#velus-side-bar"><div class="row"><div class="velus-side-bar-content"><h1 id="publications">Publications</h1>
<div class="bibtex"><h2 class="bold" id="year-2024">2024</h2><dl class="velus-bibs"><dt class="velus-bib"><a class="biblink" id="Jeanmaire24">Jeanmaire24</a></dt><dd class="velus-bib">
Paul Jeanmaire.
 <em>Une sémantique dénotationnelle pour un compilateur synchrone
  vérifié</em>.
 PhD thesis, PSL University, December 2024.<br/>
[ <a href="pubs_bib.html#Jeanmaire24">bib</a> ]
<div class="abstract"><p>

    Lustre is a synchronous dataflow language. Its discrete temporal
    structure and clocking system guarantee statically bounded execution
    time and memory consumption, favoring its adoption in mission-critical
    systems, notably within the Scade industrial tool. Vélus, developed at
    Inria, is a verified Lustre compiler. Based on the definition of formal
    semantics for each intermediate language, it provides a proof that a
    Lustre program and its translation into Clight (the language supported
    by CompCert) exhibit identical behaviors.</p><p>
    In this thesis, we develop a new model of the input language's dataflow
    kernel, based on synchronous denotational semantics, and give the exact
    conditions for its equivalence with the existing relational model in
    Vélus. This constructive approach results in an executable semantics,
    reinforcing the main correctness theorem of the compilation. Thanks to
    Scott's induction principle, specific to denotational semantics, we are
    able to conduct very natural reasoning on program dynamics, but with
    explicit treatment of errors that may occur at runtime. Finally, we
    explore the possibility of freeing ourselves from language
    synchronization constraints by proposing a formal correspondence between
    our model and that of Kahn's networks. We outline the principles of the
    infrastructure required for an end-to-end verified reasoning on
    compilable programs.
  
</p></div>

</dd></dl></div><div class="bibtex"><h2 class="bold" id="year-2023">2023</h2><dl class="velus-bibs"><dt class="velus-bib"><a class="biblink" id="Pesin23">Pesin23</a></dt><dd class="velus-bib">
Basile Pesin.
 <em>Verified Compilation of a Synchronous Dataflow Language with
  State Machines</em>.
 PhD thesis, PSL University, October 2023.<br/>
[ <a href="pubs_bib.html#Pesin23">bib</a> | 
<a href="https://inria.hal.science/tel-04830529v1/file/pesin_phd.pdf">.pdf</a> ]
<div class="abstract"><p>

    Safety-critical embedded systems are often specified using block-diagram
    formalisms. SCADE Suite is a development environment for such systems
    which has been used industrially in avionics, nuclear plants, automotive
    and other safety-critical contexts for twenty years. Its graphical
    formalism translates to a textual representation based on the Lustre
    synchronous dataflow language, with extensions from later languages like
    Lucid Synchrone. In Lustre, a program is defined as a set of equations
    that relate inputs and outputs of the program at each discrete time
    step. The language of expressions at right of equations includes
    arithmetic and logic operators, delay operators that access the previous
    value of an expression, and sampling operators that allow some values to
    be calculated less often than others.</p><p>
    The Vélus project aims at formalizing a subset of the Scade 6 language
    in the Coq Proof Assistant. It proposes a specification of the dynamic
    semantics of the language as a relation between infinite streams of
    inputs and outputs. It also includes a compiler that uses CompCert, a
    verified compiler for C, as its back end to produce assembly code, and
    an end-to-end proof that compilation preserves the semantics of dataflow
    programs.</p><p>
    In this thesis, we extend Vélus to support control blocks present in
    Scade 6 and Lucid Synchrone, which includes a construction that controls
    the activation of equations based on a condition (switch), a
    construction that accesses the previous value of a named variable
    (last), a construction that re-initializes delay operators (reset), and
    finally, hierarchical state machines, which allow for the definition of
    complex modal behaviors. All of these constructions may be arbitrarily
    nested in a program. We extend the existing semantics of Vélus with a
    novel specification for these constructs that encodes their behavior
    using sampling. We propose a generic induction principle for well-formed
    programs, which is used to prove properties of the semantic model such
    as determinism and type system correctness. Finally, we describe the
    extension of the Vélus compiler to handle these new constructs. We show
    that the existing compilation scheme that lowers these constructs into
    the core dataflow language can be implemented, specified and verified in
    Coq. Compiling the reset and last constructs requires deeper changes in
    the intermediate languages of Vélus.
  
</p></div>

</dd><dt class="velus-bib"><a class="biblink" id="EMSOFT23">EMSOFT23</a></dt><dd class="velus-bib">
Timothy Bourke, Basile Pesin, and Marc Pouzet.
 Verified compilation of synchronous dataflow with state machines.
 <em>ACM Transactions on Embedded Computing Systems</em>,
  22(5s):137:1–137:26, September 2023.
 ESWEEK special issue including presentations at the 23rd Int. Conf.
  on Embedded Software (EMSOFT 2023).<br/>
[ <a href="pubs_bib.html#EMSOFT23">bib</a> | 
<a href="http://dx.doi.org/10.1145/3608102">DOI</a> | 
<a href="https://velus.inria.fr/emsoft2023/">http</a> | 
<a href="https://inria.hal.science/hal-04201401v1/file/velus-emsoft2023.pdf">.pdf</a> ]
<div class="abstract"><p>

    Safety-critical embedded software is routinely programmed in
    block-diagram languages. Recent work in the Vélus project specifies such
    a language and its compiler in the Coq proof assistant. It builds on the
    CompCert verified C compiler to give an end-to-end proof linking the
    dataflow semantics of source programs to traces of the generated
    assembly code. We extend this work with switched blocks, shared
    variables, reset blocks, and state machines; define a relational
    semantics to integrate these block- and mode-based constructions into
    the existing stream-based model; adapt the standard source-to-source
    rewriting scheme to compile the new constructions; and reestablish the
    correctness theorem.
  
</p></div>

</dd><dt class="velus-bib"><a class="biblink" id="JFLA23">JFLA23</a></dt><dd class="velus-bib">
Timothy Bourke, Basile Pesin, and Marc Pouzet.
 Analyse de dépendance vérifiée pour un langage
  synchrone à flot de données.
 In Timothy Bourke and Delphine Demange, editors, <em>JFLA 2023 -
  Les trente-quatrièmes Journées Francophones des Langages
  Applicatifs</em>, pages 101–120, Praz-sur-Arly, France, January/February 2023.<br/>
[ <a href="pubs_bib.html#JFLA23">bib</a> | 
<a href="https://velus.inria.fr/jfla2023/">http</a> | 
<a href="https://hal.inria.fr/hal-03936656/file/jfla23_paper_6388.pdf">.pdf</a> ]
<div class="abstract"><p>

    Vélus is a formalisation of a synchronous dataflow language and 
    compiler in the Coq proof assistant.
    It includes a definition of the source language's dynamic semantics,
    a compiler that produces imperative code,
    and an end-to-end proof that the compiler preserves the semantics of
    programs.</p><p>
    In this article, we extend Vélus with the semantics of two activation
    structures that are provided by modern compilers:
    switchs and local declarations.
    These new constructions require adapting the static dependency analysis
    of Vélus, which produces an acyclic graph as a witness that a program is
    well formed.
    We use this witness to construct an induction schema and apply it to
    show, in Coq, that the semantic model is deterministic.
  
</p></div>

</dd></dl></div><div class="bibtex"><h2 class="bold" id="year-2022">2022</h2><dl class="velus-bibs"><dt class="velus-bib"><a class="biblink" id="TYPES22">TYPES22</a></dt><dd class="velus-bib">
Timothy Bourke, Paul Jeanmaire, and Marc Pouzet.
 Towards a denotational semantics of streams for a verified Lustre
  compiler (short talk).
 In <em>28th International Conference on Types for Proofs and
  Programs</em>, Nantes, France, June 2022.<br/>
[ <a href="pubs_bib.html#TYPES22">bib</a> | 
<a href="https://types22.inria.fr/files/2022/06/TYPES_2022_paper_28.pdf">.pdf</a> ]
<div class="abstract"><p>

    This short talk presents work in progress to develop a denotational
    semantics in the Coq proof assistant for the Vélus verified Lustre
    compiler. It describes the current correctness theorem and proposes an
    approach to mitigate certain of its limitations by building on an
    existing library for Complete Partial Orders (CPOs).
  
</p></div>

</dd></dl></div><div class="bibtex"><h2 class="bold" id="year-2021">2021</h2><dl class="velus-bibs"><dt class="velus-bib"><a class="biblink" id="EMSOFT21">EMSOFT21</a></dt><dd class="velus-bib">
Timothy Bourke, Paul Jeanmaire, Basile Pesin, and Marc Pouzet.
 Verified Lustre normalization with node subsampling.
 <em>ACM Transactions on Embedded Computing Systems</em>, 20(5s):Article
  98, October 2021.
 ESWEEK special issue including presentations at the 21st Int. Conf.
  on Embedded Software (EMSOFT 2021).<br/>
[ <a href="pubs_bib.html#EMSOFT21">bib</a> | 
<a href="http://dx.doi.org/10.1145/3477041">DOI</a> | 
<a href="https://velus.inria.fr/emsoft2021/">http</a> | 
<a href="https://hal.inria.fr/hal-03370264/file/paper.pdf">.pdf</a> ]
<div class="abstract"><p>

    Dataflow languages allow the specification of reactive systems by
    mutually recursive stream equations, functions, and boolean activation
    conditions called clocks. Lustre and Scade are dataflow languages for
    programming embedded systems. Dataflow programs are compiled by a
    succession of passes. This article focuses on the normalization pass
    which rewrites programs into the simpler form required for code
    generation.</p><p>
    Vélus is a compiler from a normalized form of Lustre to CompCert's
    Clight language. Its specification in the Coq interactive theorem prover
    includes an end-to-end correctness proof that the values prescribed by
    the dataflow semantics of source programs are produced by executions of
    generated assembly code. We describe how to extend Vélus with a
    normalization pass and to allow subsampled node inputs and outputs. We
    propose semantic definitions for the unrestricted language, divide
    normalization into three steps to facilitate proofs, adapt the clock
    type system to handle richer node definitions, and extend the end-to-end
    correctness theorem to incorporate the new features. The proofs require
    reasoning about the relation between static clock annotations and the
    presence and absence of values in the dynamic semantics. The
    generalization of node inputs requires adding a compiler pass to ensure
    the initialization of variables passed in function calls.
  
</p></div>

</dd><dt class="velus-bib"><a class="biblink" id="JFLA21">JFLA21</a></dt><dd class="velus-bib">
Timothy Bourke, Paul Jeanmaire, Basile Pesin, and Marc Pouzet.
 Normalisation vérifiée du langage Lustre.
 In <em>JFLA 2021 - Les trente-deuxièmes Journées
  Francophones des Langages Applicatifs</em>, pages 117–133, Online, April 2021.<br/>
[ <a href="pubs_bib.html#JFLA21">bib</a> | 
<a href="https://hal.inria.fr/hal-03287572">http</a> | 
<a href="https://hal.inria.fr/hal-03287572/file/jfla.pdf">.pdf</a> ]
<div class="abstract"><p>

    Lustre is a synchronous dataflow language designed for programming
    embedded systems. In the Vélus project, we use Coq to develop and
    formalize a compiler that accepts a normalized form of the language and
    produces imperative code. While this restricted form is suitable for
    code generated from a user interface based on block diagrams, we wanted
    to allow programmers to use the complete language.</p><p>
    In this article, we present the normalization pass that transforms the
    complete language into the normalized one. This transformation is
    divided into three steps so as to simplify the correctness proofs. To
    show that the semantics is preserved, it is necessary to prove that the
    three steps preserve certain static and dynamic properties of the
    language. In particular, the relation between the clock types and the
    dynamic semantic must be established.
  
</p></div>

</dd></dl></div><div class="bibtex"><h2 class="bold" id="year-2020">2020</h2><dl class="velus-bibs"><dt class="velus-bib"><a class="biblink" id="Brun20">Brun20</a></dt><dd class="velus-bib">
Lélio Brun.
 <em>Mechanized Semantics and Verified Compilation for a Dataflow
  Synchronous Language with Reset</em>.
 PhD thesis, PSL Research University, June 2020.<br/>
[ <a href="pubs_bib.html#Brun20">bib</a> | 
<a href="https://theses.hal.science/tel-03068862/file/Brun-2020-These.pdf">.pdf</a> ]
<div class="abstract"><p>

    Specifications based on block diagrams and state machines are used to
    design control software, especially in the certified development of
    safety-critical applications. Tools like Scade and Simulink/Stateflow
    are equipped with compilers that translate such specifications into
    executable code. They provide programming languages for composing
    functions over streams as typified by dataflow synchronous languages
    like Lustre.</p><p>
    In this thesis we present Vélus, a Lustre compiler verified in the
    interactive theorem prover Coq. We develop semantic models for the
    various languages in the compilation chain, and build on the verified
    CompCert C compiler to generate executable code and give an end-to-end
    correctness proof. The main challenge is to show semantic preservation
    between the dataflow paradigm and the imperative paradigm, and to reason
    about byte-level representations of program states.</p><p>
    We treat, in particular, the modular reset construct, a primitive for
    resetting subsystems. This necessitates the design of suitable semantic
    models, compilation algorithms and corresponding correctness proofs. We
    introduce a novel intermediate language into the usual clock-directed
    modular compilation scheme of Lustre. This permits the implementation of
    compilation passes that generate better sequential code, and facilitates
    reasoning about the correctness of the successive transformations of the
    modular reset construct.
  
</p></div>

</dd><dt class="velus-bib"><a class="biblink" id="POPL20">POPL20</a></dt><dd class="velus-bib">
Timothy Bourke, Lélio Brun, and Marc Pouzet.
 Mechanized semantics and verified compilation for a dataflow
  synchronous language with reset.
 <em>Proceedings of the ACM on Programming Languages</em>,
  4(POPL):1–29, January 2020.<br/>
[ <a href="pubs_bib.html#POPL20">bib</a> | 
<a href="http://dx.doi.org/10.1145/3371112">DOI</a> | 
<a href="https://hal.inria.fr/hal-02426573">http</a> | 
<a href="https://dl.acm.org/doi/pdf/10.1145/3371112?download=true&amp;.pdf">.pdf</a> ]
<div class="abstract"><p>

    Specifications based on block diagrams and state machines are used to
    design control software, especially in the certified development of
    safety-critical applications. Tools like SCADE Suite and
    Simulink/Stateflow are equipped with compilers that translate such
    specifications into executable code. They provide programming languages
    for composing functions over streams as typified by Dataflow Synchronous
    Languages like Lustre.</p><p>
    Recent work builds on CompCert to specify and verify a compiler for the
    core of Lustre in the Coq Interactive Theorem Prover. It formally links
    the stream-based semantics of the source language to the sequential
    memory manipulations of generated assembly code. We extend this work to
    treat a primitive for resetting subsystems. Our contributions include
    new semantic rules that are suitable for mechanized reasoning, a novel
    intermediate language for generating optimized code, and proofs of
    correctness for the associated compilation passes.
  
</p></div>

</dd></dl></div><div class="bibtex"><h2 class="bold" id="year-2019">2019</h2><dl class="velus-bibs"><dt class="velus-bib"><a class="biblink" id="JFLA19">JFLA19</a></dt><dd class="velus-bib">
Timothy Bourke and Marc Pouzet.
 Clocked arguments in a verified Lustre compiler.
 In <em>JFLA 2019 - Les trentièmes Journées Francophones des
  Langages Applicatifs</em>, Les actes des trentièmes Journées
  Francophones des Langages Applicatifs (JFLA 2019), page 16, Les Rousses,
  France, January 2019.<br/>
[ <a href="pubs_bib.html#JFLA19">bib</a> | 
<a href="https://hal.inria.fr/hal-02005639">http</a> | 
<a href="https://hal.inria.fr/hal-02005639/file/bourke-pouzet-jfla2019.pdf">.pdf</a> ]
<div class="abstract"><p>

    Lustre is a synchronous language for programming systems as block
    diagrams from which low-level imperative code is generated
    automatically. Recent work applies the Coq interactive proof assistant
    to specify a compiler from a core subset of Lustre to the Clight input
    language of CompCert from which assembly code is generated. The overall
    correctness proof connects the stream semantics of Lustre to the
    imperative semantics of the assembly code.</p><p>
    Every stream in a Lustre program is associated with a static ‘clock’
    that represents when it is active. Compilation transforms the clocks
    into conditional statements that control when the corresponding value
    are calculated. Previous work made the simplifying assumption that the
    inputs and outputs of any given block shared the same static clock. This
    paper describes one way to lift this restriction. It requires enriching
    the static typing rules for clocks and the semantic model, and, to
    satisfy the Clight semantics, adding a compilation pass to ensure that
    any variable passed to a function call has been initialized.
  
</p></div>

</dd></dl></div><div class="bibtex"><h2 class="bold" id="year-2018">2018</h2><dl class="velus-bibs"><dt class="velus-bib"><a class="biblink" id="SCOPES18">SCOPES18</a></dt><dd class="velus-bib">
Timothy Bourke, Lélio Brun, and Marc Pouzet.
 Towards a verified Lustre compiler with modular reset.
 In <em>21st International Workshop on Software and Compilers for
  Embedded Systems (SCOPES 2018)</em>, Proceedings of the 21st International
  Workshop on Software and Compilers for Embedded Systems (SCOPES 2018),
  page 4, Sankt Goar, Germany, May 2018. ACM Press.<br/>
[ <a href="pubs_bib.html#SCOPES18">bib</a> | 
<a href="http://dx.doi.org/10.1145/3207719.3207732">DOI</a> | 
<a href="https://hal.inria.fr/hal-01817949">http</a> | 
<a href="https://hal.inria.fr/hal-01817949/file/paper.pdf">.pdf</a> ]
<div class="abstract"><p>

    This paper presents ongoing work to add a modular reset construct to a
    verified Lustre compiler. We present a novel formal specification for
    the construct and sketch our plans to integrate it into the compiler and
    its correctness proof.
  
</p></div>

</dd></dl></div><div class="bibtex"><h2 class="bold" id="year-2017">2017</h2><dl class="velus-bibs"><dt class="velus-bib"><a class="biblink" id="PLDI17">PLDI17</a></dt><dd class="velus-bib">
Timothy Bourke, Lélio Brun, Pierre-Evariste Dagand, Xavier Leroy, Marc
  Pouzet, and Lionel Rieg.
 A Formally Verified Compiler for Lustre.
 In <em>PLDI 2017 - 38th ACM SIGPLAN Conference on Programming
  Language Design and Implementation</em>, Barcelone, Spain, June 2017. ACM.<br/>
[ <a href="pubs_bib.html#PLDI17">bib</a> | 
<a href="https://hal.inria.fr/hal-01512286">http</a> | 
<a href="https://hal.inria.fr/hal-01512286/file/velus-pldi17.pdf">.pdf</a> ]
<div class="abstract"><p>

    The correct compilation of block diagram languages like Lustre, Scade,
    and a discrete subset of Simulink is important since they are used to
    program critical embedded control software. We describe the
    specification and verification in an Interactive Theorem Prover of a
    compilation chain that treats the key aspects of Lustre: sampling,
    nodes, and delays. Building on CompCert, we show that repeated execution
    of the generated assembly code faithfully implements the dataflow
    semantics of source programs.</p><p>
    We resolve two key technical challenges. The first is the change from a
    synchronous dataflow semantics, where programs manipulate streams of
    values, to an imperative one, where computations manipulate memory
    sequentially. The second is the verified compilation of an imperative
    language with encapsulated state to C code where the state is realized
    by nested records. We also treat a standard control optimization that
    eliminates unnecessary conditional statements.
  
</p></div>

</dd><dt class="velus-bib"><a class="biblink" id="JFLA17">JFLA17</a></dt><dd class="velus-bib">
Timothy Bourke, Pierre-Evariste Dagand, Marc Pouzet, and Lionel Rieg.
 Vérification de la génération modulaire du code
  impératif pour Lustre.
 In <em>JFLA 2017 - Vingt-huitième Journées Francophones des
  Langages Applicatifs</em>, Gourette, France, January 2017.<br/>
[ <a href="pubs_bib.html#JFLA17">bib</a> | 
<a href="https://hal.inria.fr/hal-01403830">http</a> | 
<a href="https://hal.inria.fr/hal-01403830/file/bourke%20%281%29.pdf">.pdf</a> ]
<div class="abstract"><p>

    Synchronous languages are used to program critical control applications.
    The Scade language, used in industry for these applications, is based on
    the Lustre language introduced by Caspi and Halbwachs. In this article
    we treat the formalization and proof, in the Coq proof assistant, of a
    key compilation pass: the translation of programs from Lustre into an
    imperative language. The challenge is to change from a synchronous
    dataflow semantics, where programs manipulate streams, to an imperative
    semantics, where the program manipulates memory sequentially. We specify
    and verify a simple code generator that treats core Lustre features:
    sampling, nodes, and delays. The proof uses an intermediate semantic
    model that mixes dataflow and imperative characteristics and allows the
    statement of an essential inductive invariant. We exploit this
    formalization to verify a classic optimization that fuses conditional
    structures in the generated imperative code.
  
</p></div>

</dd></dl></div></div><div class="velus-side-bar-menu"><div class="velus-side-bar-outer"><div class="velus-side-bar bg-faded" id="velus-side-bar"><ul class="nav nav-pills flex-column"><li class="nav-item"><a class="nav-link" href="#year-2024">2024</a></li><li class="nav-item"><a class="nav-link" href="#year-2023">2023</a></li><li class="nav-item"><a class="nav-link" href="#year-2022">2022</a></li><li class="nav-item"><a class="nav-link" href="#year-2021">2021</a></li><li class="nav-item"><a class="nav-link" href="#year-2020">2020</a></li><li class="nav-item"><a class="nav-link" href="#year-2019">2019</a></li><li class="nav-item"><a class="nav-link" href="#year-2018">2018</a></li><li class="nav-item"><a class="nav-link" href="#year-2017">2017</a></li></ul></div></div></div></div></div><div class="navbar navbar-expand-md fixed-top navbar-dark bg-primary velus-navbar"><a class="navbar-brand" href="index.html">Vélus</a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#collapsingNavbar" aria-expanded="false" aria-label="Toggle navigation">•••</button><div class="collapse navbar-collapse" id="collapsingNavbar"><ul class="navbar-nav mr-auto"><li class="nav-item"><a class="nav-link" href="compiler.html">compiler</a></li><li class="nav-item active"><a class="nav-link" href="publications.html">publications</a></li><li class="nav-item"><a class="nav-link" href="tryvelus/index.html">demo</a></li><li class="nav-item"><a class="nav-link" href="emsoft2023/index.html">EMSOFT2023</a></li></ul></div></div><script crossorigin="anonymous" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" src="https://code.jquery.com/jquery-3.3.1.slim.min.js"></script><script crossorigin="anonymous" integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js"></script><script crossorigin="anonymous" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js"></script><script>$('body').scrollspy({ target: '#velus-side-bar' })</script></div></body></html>